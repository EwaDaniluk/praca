import os
from pathlib import Path

import numpy as np
from natsort import natsorted  # jeśli potrzeba: pip install natsort


def load_coords_from_xyz(xyz_path: Path, nbeads: int = 100) -> np.ndarray:
    """
    Wczytaj współrzędne z pliku .xyz wygenerowanego przez KnotPlot:
    - pierwsza linia: "Component 1 of 1:"
    - kolejne nbeads linii: "x y z"
    """
    data = np.loadtxt(xyz_path, skiprows=1)
    if data.shape != (nbeads, 3):
        raise ValueError(
            f"{xyz_path} ma kształt {data.shape}, a oczekiwano ({nbeads}, 3)."
        )
    return data


def compute_tangents(coords: np.ndarray) -> np.ndarray:
    """
    T(i) = znormalizowany wektor od beada i do beada i+1 (łańcuch zamknięty).
    """
    n = coords.shape[0]
    segs = coords[(np.arange(n) + 1) % n] - coords
    norms = np.linalg.norm(segs, axis=1, keepdims=True)
    norms[norms == 0.0] = 1.0  # zabezpieczenie przed zerową długością
    tangents = segs / norms
    return tangents


def compute_sts_matrix(coords: np.ndarray) -> np.ndarray:
    """
    Dyskretna wersja StS writhe (eq. (1) w artykule):

        ω_StS(i,j) = ( t_i × t_j ) · ( r_i − r_j ) / |r_i − r_j|^3

    Zwraca macierz (N, N).
    """
    n = coords.shape[0]
    r = coords
    t = compute_tangents(coords)

    r_i = r[:, None, :]    # (N,1,3)
    r_j = r[None, :, :]    # (1,N,3)
    diff = r_i - r_j       # (N,N,3)
    dist = np.linalg.norm(diff, axis=2)  # (N,N)
    dist3 = dist ** 3

    t_i = t[:, None, :]    # (N,1,3)
    t_j = t[None, :, :]    # (1,N,3)
    cross = np.cross(t_i, t_j)  # (N,N,3)

    numer = np.einsum("ijk,ijk->ij", cross, diff)  # (N,N)

    with np.errstate(divide="ignore", invalid="ignore"):
        sts = np.where(dist3 > 0.0, numer / dist3, 0.0)

    # własny segment z samym sobą nie wnosi wkładu
    np.fill_diagonal(sts, 0.0)

    return sts


def compute_stA_from_sts(sts: np.ndarray) -> np.ndarray:
    """
    StA(x) = ∑_y ω_StS(x,y): suma po drugim indeksie macierzy.
    """
    return sts.sum(axis=1)


def smooth_periodic(arr: np.ndarray, window: int) -> np.ndarray:
    """
    Proste „okno” wygładzające na okręgu (łańcuch zamknięty):
    dla każdego i bierzemy średnią z window sąsiednich punktów (z zawijaniem).
    """
    n = len(arr)
    k = window
    half = k // 2
    out = np.empty_like(arr)
    for i in range(n):
        idxs = [(i + offset) % n for offset in range(-half, half + 1)]
        out[i] = arr[idxs].mean()
    return out


def build_SIGWRITHElw10_for_knot(
    knot_name: str,
    input_dir: str,
    output_file: str,
    nbeads: int = 100,
    window_beads: int = 10,
) -> None:
    """
    Dla wszystkich plików {knot_name}_*.xyz w katalogu input_dir:

    1. Wczytuje współrzędne (100 punktów).
    2. Liczy macierz StS, potem StA(i) = ∑_j StS(i,j).
    3. Wygładza StA(x) oknem o długości 'window_beads' (na okręgu).
    4. Zapisuje do pliku:
         # conf_id bead_id signed_writhe_lw10
         1   1   ω_1
         1   2   ω_2
         ...
         1 100  ω_100
         2   1  ω_1
         ...
    """
    input_path = Path(input_dir)
    if not input_path.is_dir():
        raise FileNotFoundError(f"Katalog wejściowy nie istnieje: {input_dir}")

    xyz_files = [p for p in input_path.glob(f"{knot_name}_*.xyz") if p.is_file()]
    if not xyz_files:
        raise FileNotFoundError(f"Nie znaleziono plików {knot_name}_*.xyz w {input_dir}")

    xyz_files = natsorted(xyz_files)
    print(f"Znalazłem {len(xyz_files)} plików dla węzła {knot_name}")

    output_path = Path(output_file)
    output_path.parent.mkdir(parents=True, exist_ok=True)

    with output_path.open("w", encoding="utf-8") as out_f:
        # nagłówek – load_dataset i tak go pominie, ważne żeby JEDNA linia była
        out_f.write("# conf_id bead_id signed_writhe_lw10\n")

        total_confs = 0
        for conf_id, xyz_file in enumerate(xyz_files, start=1):
            coords = load_coords_from_xyz(xyz_file, nbeads=nbeads)

            sts = compute_sts_matrix(coords)
            stA = compute_stA_from_sts(sts)
            stA_smoothed = smooth_periodic(stA, window=window_beads)

            if len(stA_smoothed) != nbeads:
                raise ValueError(
                    f"StA dla {xyz_file} ma długość {len(stA_smoothed)}, "
                    f"a oczekiwano {nbeads}"
                )

            # zapis: conf_id, bead_id, wartość
            for bead_id, value in enumerate(stA_smoothed, start=1):
                out_f.write(f"{conf_id} {bead_id} {value:.10e}\n")

            total_confs += 1
            if conf_id % 10 == 0:
                print(f"Przetworzono {conf_id} plików...")

    print(f"Zapisano {total_confs} konformacji do pliku: {output_path}")


if __name__ == "__main__":
    knot_name = "0_1"

    # katalog z konformacjami z KnotPlot
    input_dir = r"C:\Users\danil\KnotPlot\0_1_200"

    # docelowy plik zgodny ze strukturą MLKnotsProject
    output_file = (
        r"C:\Users\danil\.vscode\praca\MASTER\0_1\N100\lp10\SIGWRITHE\3DSignedWrithe_0_1.dat.lp10.dat.nos"
    )

    build_SIGWRITHElw10_for_knot(
        knot_name=knot_name,
        input_dir=input_dir,
        output_file=output_file,
        nbeads=100,
        window_beads=10,  # "lw10"
    )
