import os
from pathlib import Path
from natsort import natsorted  # jeśli nie masz: pip install natsort


def build_xyz_dataset_for_knot(
    knot_name: str,
    input_dir: str,
    output_file: str,
    nbeads: int = 100,
) -> None:
    """
    Wczytuje wszystkie pliki *.xyz z katalogu input_dir (np. 0_1_001.xyz, 0_1_002.xyz, ...)
    i zapisuje je w jednym pliku output_file w formacie wymaganym przez eksperyment:
    - bez nagłówka ("Component 1 of 1:")
    - dla każdej konformacji dokładnie nbeads linii "x y z"
    - konformacje jedna po drugiej, bez pustych linii.
    """
    input_path = Path(input_dir)

    if not input_path.is_dir():
        raise FileNotFoundError(f"Katalog wejściowy nie istnieje: {input_dir}")

    # Wszystkie pliki knot_name_*.xyz (np. 0_1_000001.xyz, 0_1_000002.xyz, ...)
    xyz_files = [p for p in input_path.glob(f"{knot_name}_*.xyz") if p.is_file()]
    if not xyz_files:
        raise FileNotFoundError(f"Nie znaleziono plików {knot_name}_*.xyz w {input_dir}")

    # Sortowanie naturalne: 0_1_001, 0_1_002, ..., 0_1_100000
    xyz_files = natsorted(xyz_files)

    print(f"[{knot_name}] Znalazłem {len(xyz_files)} plików w {input_dir}")

    output_path = Path(output_file)
    output_path.parent.mkdir(parents=True, exist_ok=True)

    with output_path.open("w", encoding="utf-8") as out_f:
        total_confs = 0

        for file_idx, xyz_file in enumerate(xyz_files, start=1):
            with xyz_file.open("r", encoding="utf-8", errors="replace") as f:
                # Pomijamy pierwszą linię: "Component 1 of 1:"
                header = f.readline()

                # Wczytujemy wszystkie linie z współrzędnymi, pomijając puste
                coords = [line.strip() for line in f if line.strip()]

            if len(coords) != nbeads:
                raise ValueError(
                    f"Plik {xyz_file} ma {len(coords)} linii z współrzędnymi, "
                    f"a oczekiwano {nbeads}."
                )

            # Zapisujemy do pliku wyjściowego
            for line in coords:
                out_f.write(line + "\n")

            total_confs += 1
            if file_idx % 100 == 0:
                print(f"[{knot_name}] Przetworzono {file_idx} plików...")

    print(f"[{knot_name}] Zapisano {total_confs} konformacji do pliku: {output_path}")


def build_xyz_for_all_knots(
    knots,
    base_input_dir: str,
    base_master_dir: str,
    nbeads: int = 100,
    pers_len: int = 10,
    nconf: int = 10000,
):
    """
    Pętla po wszystkich typach węzłów.
    Zakładamy strukturę wejściową:
      base_input_dir / f"{knot}_{nconf}" / {knot}_*.xyz

    oraz strukturę wyjściową zgodną z projektem:
      base_master_dir / knot / f"N{nbeads}" / f"lp{pers_len}" / "XYZ" / f"XYZ_{knot}.dat.nos"
    """
    for knot in knots:
        input_dir = os.path.join(base_input_dir, f"{knot}_{nconf}")
        output_file = os.path.join(
            base_master_dir,
            knot,
            f"N{nbeads}",
            f"lp{pers_len}",
            "XYZ",
            f"XYZ_{knot}.dat.nos",
        )

        print(f"\n=== Przetwarzam węzeł {knot} ===")
        print(f"Wejście : {input_dir}")
        print(f"Wyjście : {output_file}")

        build_xyz_dataset_for_knot(
            knot_name=knot,
            input_dir=input_dir,
            output_file=output_file,
            nbeads=nbeads,
        )


if __name__ == "__main__":
    # Lista Twoich węzłów
    #knots = ["0_1", "3_1", "4_1", "5_1", "5_2"]
    knots = ["6_1", "6_2", "6_3"]

    # Root z katalogami 0_1_200, 3_1_200, ...
    base_input_dir = r"C:\Users\danil\KnotPlot"

    # Root repozytorium z danymi do ML (MASTER)
    base_master_dir = r"C:\Users\danil\.vscode\praca\MASTER"

    # Parametry datasetu
    nbeads = 100
    pers_len = 10

    # Tu zmieniasz 200 -> 100000, gdy zrobisz większy dataset
    nconf = 10000

    build_xyz_for_all_knots(
        knots=knots,
        base_input_dir=base_input_dir,
        base_master_dir=base_master_dir,
        nbeads=nbeads,
        pers_len=pers_len,
        nconf=nconf,
    )
