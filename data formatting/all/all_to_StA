import os
from pathlib import Path

import numpy as np
from natsort import natsorted  # jeśli potrzeba: pip install natsort


def load_coords_from_xyz(xyz_path: Path, nbeads: int = 100) -> np.ndarray:
    """
    Wczytaj współrzędne z pliku .xyz wygenerowanego przez KnotPlot:
    - pierwsza linia: "Component 1 of 1:"
    - kolejne nbeads linii: "x y z"
    """
    data = np.loadtxt(xyz_path, skiprows=1)
    if data.shape != (nbeads, 3):
        raise ValueError(
            f"{xyz_path} ma kształt {data.shape}, a oczekiwano ({nbeads}, 3)."
        )
    return data


def compute_tangents(coords: np.ndarray) -> np.ndarray:
    """
    T(i) = znormalizowany wektor od beada i do beada i+1 (łańcuch zamknięty).
    """
    n = coords.shape[0]
    segs = coords[(np.arange(n) + 1) % n] - coords
    norms = np.linalg.norm(segs, axis=1, keepdims=True)
    norms[norms == 0.0] = 1.0  # zabezpieczenie przed zerową długością
    tangents = segs / norms
    return tangents


def compute_sts_matrix(coords: np.ndarray) -> np.ndarray:
    """
    Dyskretna wersja StS writhe (eq. (1) w artykule):

        ω_StS(i,j) = ( t_i × t_j ) · ( r_i − r_j ) / |r_i − r_j|^3

    Zwraca macierz (N, N).
    """
    n = coords.shape[0]
    r = coords
    t = compute_tangents(coords)

    r_i = r[:, None, :]    # (N,1,3)
    r_j = r[None, :, :]    # (1,N,3)
    diff = r_i - r_j       # (N,N,3)
    dist = np.linalg.norm(diff, axis=2)  # (N,N)
    dist3 = dist ** 3

    t_i = t[:, None, :]    # (N,1,3)
    t_j = t[None, :, :]    # (1,N,3)
    cross = np.cross(t_i, t_j)  # (N,N,3)

    numer = np.einsum("ijk,ijk->ij", cross, diff)  # (N,N)

    with np.errstate(divide="ignore", invalid="ignore"):
        sts = np.where(dist3 > 0.0, numer / dist3, 0.0)

    # własny segment z samym sobą nie wnosi wkładu
    np.fill_diagonal(sts, 0.0)

    return sts


def compute_stA_from_sts(sts: np.ndarray) -> np.ndarray:
    """
    StA(x) = ∑_y ω_StS(x,y): suma po drugim indeksie macierzy.
    """
    return sts.sum(axis=1)


def smooth_periodic(arr: np.ndarray, window: int) -> np.ndarray:
    """
    Proste „okno” wygładzające na okręgu (łańcuch zamknięty):
    dla każdego i bierzemy średnią z window sąsiednich punktów (z zawijaniem).
    """
    n = len(arr)
    k = window
    half = k // 2
    out = np.empty_like(arr)
    for i in range(n):
        idxs = [(i + offset) % n for offset in range(-half, half + 1)]
        out[i] = arr[idxs].mean()
    return out


def build_SIGWRITHElw10_for_knot(
    knot_name: str,
    input_dir: str,
    output_file: str,
    nbeads: int = 100,
    window_beads: int = 10,
) -> None:
    """
    Dla wszystkich plików {knot_name}_*.xyz w katalogu input_dir:

    1. Wczytuje współrzędne (100 punktów).
    2. Liczy macierz StS, potem StA(i) = ∑_j StS(i,j).
    3. Wygładza StA(x) oknem o długości 'window_beads' (na okręgu).
    4. Zapisuje do pliku:
         # conf_id bead_id signed_writhe_lw10
         1   1   ω_1
         1   2   ω_2
         ...
         1 100  ω_100
         2   1  ω_1
         ...
    """
    input_path = Path(input_dir)
    if not input_path.is_dir():
        raise FileNotFoundError(f"Katalog wejściowy nie istnieje: {input_dir}")

    xyz_files = [p for p in input_path.glob(f"{knot_name}_*.xyz") if p.is_file()]
    if not xyz_files:
        raise FileNotFoundError(f"Nie znaleziono plików {knot_name}_*.xyz w {input_dir}")

    xyz_files = natsorted(xyz_files)
    print(f"[{knot_name}] Znalazłem {len(xyz_files)} plików w {input_dir}")

    output_path = Path(output_file)
    output_path.parent.mkdir(parents=True, exist_ok=True)

    with output_path.open("w", encoding="utf-8") as out_f:
        # nagłówek – load_dataset i tak go pominie, ważne żeby JEDNA linia była
        out_f.write("# conf_id bead_id signed_writhe_lw10\n")

        total_confs = 0
        for conf_id, xyz_file in enumerate(xyz_files, start=1):
            coords = load_coords_from_xyz(xyz_file, nbeads=nbeads)

            sts = compute_sts_matrix(coords)
            stA = compute_stA_from_sts(sts)
            stA_smoothed = smooth_periodic(stA, window=window_beads)

            if len(stA_smoothed) != nbeads:
                raise ValueError(
                    f"StA dla {xyz_file} ma długość {len(stA_smoothed)}, "
                    f"a oczekiwano {nbeads}"
                )

            # zapis: conf_id, bead_id, wartość
            for bead_id, value in enumerate(stA_smoothed, start=1):
                out_f.write(f"{conf_id} {bead_id} {value:.10e}\n")

            total_confs += 1
            if conf_id % 100 == 0:
                print(f"[{knot_name}] Przetworzono {conf_id} plików...")

    print(f"[{knot_name}] Zapisano {total_confs} konformacji do pliku: {output_path}")


def build_SIGWRITHElw10_for_all_knots(
    knots,
    base_input_dir: str,
    base_master_dir: str,
    nbeads: int = 100,
    pers_len: int = 10,
    nconf: int = 10000,
    window_beads: int = 10,
):
    """
    Pętla po wszystkich typach węzłów.
    Zakładamy strukturę wejściową:
      base_input_dir / f"{knot}_{nconf}" / {knot}_*.xyz

    oraz strukturę wyjściową zgodną z projektem:
      base_master_dir / knot / f"N{nbeads}" / f"lp{pers_len}" / "SIGWRITHE" /
          f"3DSignedWrithe_{knot}.dat.lp{pers_len}.dat.nos"
    """
    for knot in knots:
        input_dir = os.path.join(base_input_dir, f"{knot}_{nconf}")
        output_file = os.path.join(
            base_master_dir,
            knot,
            f"N{nbeads}",
            f"lp{pers_len}",
            "SIGWRITHE",
            f"3DSignedWrithe_{knot}.dat.lp{pers_len}.dat.nos",
        )

        print(f"\n=== Przetwarzam węzeł {knot} ===")
        print(f"Wejście : {input_dir}")
        print(f"Wyjście : {output_file}")

        build_SIGWRITHElw10_for_knot(
            knot_name=knot,
            input_dir=input_dir,
            output_file=output_file,
            nbeads=nbeads,
            window_beads=window_beads,
        )


if __name__ == "__main__":
    # Lista węzłów (5Class)
    knots = ["0_1", "3_1", "4_1", "5_1", "5_2"]

    # Root z katalogami 0_1_200, 3_1_200, ...
    base_input_dir = r"C:\Users\danil\KnotPlot"

    # Root repozytorium z danymi do ML (MASTER)
    base_master_dir = r"C:\Users\danil\.vscode\praca\MASTER"

    # Parametry datasetu
    nbeads = 100
    pers_len = 10          # lp10 => plik *.lp10.dat.nos
    nconf = 10000            # teraz 200; potem możesz zmienić na 100000
    window_beads = 10      # "lw10"

    build_SIGWRITHElw10_for_all_knots(
        knots=knots,
        base_input_dir=base_input_dir,
        base_master_dir=base_master_dir,
        nbeads=nbeads,
        pers_len=pers_len,
        nconf=nconf,
        window_beads=window_beads,
    )
